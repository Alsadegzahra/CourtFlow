from __future__ import annotations

from datetime import datetime
from pathlib import Path
from typing import Dict, Any

from pathlib import Path
from src.io_utils import read_json, write_json
from src.ffmpeg_utils import cut_clip_ffmpeg


def _update_meta_status(out_dir: Path, status: str) -> None:
    meta_path = out_dir / "meta" / "meta.json"
    meta: Dict[str, Any] = read_json(meta_path)
    meta["status"] = status
    meta["last_updated_at"] = datetime.now().isoformat(timespec="seconds")
    write_json(meta_path, meta)


def stage_01_load_calibration(out_dir: Path) -> None:
    """
    Phase 1: Load court calibration data if available.
    For now, this is a stub. Later N will produce calibration/homography.json.
    """
    calib_path = out_dir / "calibration" / "homography.json"
    if calib_path.exists():
        print(f"   âœ“ Found calibration: {calib_path.name}")
    else:
        print("   (stub) No calibration found yet. Proceeding without x_court/y_court mapping.")


def stage_02_player_detection_tracking(out_dir: Path) -> None:
    """
    Phase 1: Player detection + multi-object tracking.
    Stub for now. Later S writes tracks/tracks.json.
    """
    tracks_path = out_dir / "tracks" / "tracks.json"
    print(f"   (stub) Expected output: {tracks_path}")
    print("   (stub) S will populate tracks.json with per-frame player tracks.")


def stage_03_coordinate_mapping(out_dir: Path) -> None:
    """
    Phase 1: Map tracked pixel coordinates to court coordinates using calibration.
    Stub for now. Later Z or N can enrich tracks.json with x_court/y_court.
    """
    print("   (stub) Will map x_pixel/y_pixel -> x_court/y_court when calibration exists.")


def stage_04_analytics_report(out_dir: Path) -> None:
    """
    Phase 1: Compute analytics report from tracks.
    Stub for now. Later R fills reports/report.json.
    """
    report_path = out_dir / "reports" / "report.json"
    print(f"   (stub) Expected output: {report_path}")
    print("   (stub) R will compute Phase 1 metrics and write them into report.json.")


def stage_05_render_overlays(out_dir: Path) -> None:
    """
    Phase 1: Render visual artifacts (heatmaps, intensity plot, optional overlay video).
    Stub for now.
    """
    renders_dir = out_dir / "renders"
    print(f"   (stub) Will write render outputs to: {renders_dir}")


def _make_dummy_clips(duration_s: float):
    # Simple: 3 clips, 10s each, spaced out
    clips = []
    starts = [0, 20, 40]
    for s in starts:
        e = min(s + 10, duration_s)
        if e > s:
            clips.append({"start": float(s), "end": float(e), "reason": "dummy_test"})
    return clips


def stage_06_export_highlights(out_dir: Path) -> None:
    """
    Phase 1 (now): Export dummy clips if report.json has no highlights yet.
    Later: use real highlights generated by analytics.
    """
    meta_path = out_dir / "meta" / "meta.json"
    report_path = out_dir / "reports" / "report.json"
    highlights_dir = out_dir / "highlights"

    meta = read_json(meta_path)
    report = read_json(report_path)

    video_path = Path(meta["video_path"])
    duration = float(meta.get("video", {}).get("duration_seconds") or 0.0)
    if duration <= 0:
        duration = 60.0  # fallback

    highlights = report.get("highlights", [])
    if not highlights:
        print("   No highlights found -> generating dummy clips for testing.")
        highlights = _make_dummy_clips(duration)
        report["highlights"] = highlights
        write_json(report_path, report)

    exported = []
    for i, h in enumerate(highlights, start=1):
        out_file = highlights_dir / f"clip_{i:03d}.mp4"
        cut_clip_ffmpeg(video_path, out_file, h["start"], h["end"])
        exported.append({"file": out_file.name, **h})

    report["exported_highlights"] = exported
    write_json(report_path, report)

    print(f"   Exported {len(exported)} clips to: {highlights_dir}")


def run_pipeline(out_dir: Path) -> None:
    """
    Orchestrate the Phase 1 pipeline stages in order.
    Each stage should be independently runnable and idempotent where possible.
    """
    print("\nðŸš€ Running Phase 1 pipeline...")

    _update_meta_status(out_dir, "running")

    print("\n[01] Load calibration")
    stage_01_load_calibration(out_dir)

    print("\n[02] Player detection + tracking")
    stage_02_player_detection_tracking(out_dir)

    print("\n[03] Coordinate mapping")
    stage_03_coordinate_mapping(out_dir)

    print("\n[04] Analytics report")
    stage_04_analytics_report(out_dir)

    print("\n[05] Render overlays / artifacts")
    stage_05_render_overlays(out_dir)

    print("\n[06] Export highlights")
    stage_06_export_highlights(out_dir)

    _update_meta_status(out_dir, "pipeline_complete")

    print("\nâœ… Pipeline finished (stubs). Next: plug in S/R/N implementations.")
